<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
    <!-- Compiled and minified CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.98.2/css/materialize.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.98.2/js/materialize.min.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Gugi" rel="stylesheet">
  <style type="text/css">
  
  body {
    background-image: url("football-452569_1920") !important;
    background-position: right bottom, left top;
    background-repeat: no-repeat, repeat;
  }
  .login_errors {
     background-color: #e57373;
     color: white;
  }
  </style>
  <script type="text/javascript">
 /*
 *
 *  Air Horner
 *  Copyright 2015 Google Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the 'License');
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an 'AS IS' BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License
 *
 */
(function() {
'use strict';

const Horn = function() {
  // The Horn Player.

  const audioSrc = '/sounds/airhorn.mp3';
  let noAudioContext = false;
  let fallbackAudio;
  let audioCtx = (window.AudioContext || window.webkitAudioContext);
  const self = this;
  let source;
  let buffer;

  if (audioCtx !== undefined) {
    audioCtx = new audioCtx();
  } else {
    noAudioContext = true;
    fallbackAudio = document.createElement('audio');
  }

  const loadSound = function(callback) {
    callback = callback || function() {};

    if (noAudioContext) {
      fallbackAudio.src = audioSrc;
      return;
    }

    // AudioContext must be resumed after the document received a user gesture to enable audio playback.
    audioCtx.resume();

    if (!!buffer == true) {
      // If the buffer is already loaded, use that.
      callback(buffer);
      return;
    }
    
    const xhr = new XMLHttpRequest();

    xhr.onload = function() {
      audioCtx.decodeAudioData(xhr.response, function(decodedBuffer) {
        callback(decodedBuffer);
      });
    };

    xhr.open('GET', audioSrc);
    xhr.responseType = 'arraybuffer';
    xhr.send();
  };


  this.start = function(opts) {
    const shouldLoop = opts.loop; // always loop if from an event.

    if (noAudioContext) {
      fallbackAudio.loop = shouldLoop;
      fallbackAudio.currentTime = 0;
      fallbackAudio.play();
      return;
    }

    loadSound(function(tmpBuffer) {
      source = audioCtx.createBufferSource();

      source.connect(audioCtx.destination);

      source.buffer = tmpBuffer;

      source.onended = function() {
        self.stop();
      };

      source.start(0);
      source.loop = shouldLoop;
      source.loopStart = 0.24;
      source.loopEnd = 0.34;
    });
  };

  this.stop = function() {
    if (!!source === true) {
      source.loop = false;
    }

    if (noAudioContext) {
      fallbackAudio.loop = false;
      fallbackAudio.pause();
    }

    this.onstopped();
  };

  this.onstopped = function() {};

  const init = function() {
    loadSound(function(decodedBuffer) {
      buffer = decodedBuffer;
    });
  };

  init();
};

const Installer = function(root) {
  let promptEvent;

  const install = function(e) {
    if(promptEvent) {
      promptEvent.prompt();
      promptEvent.userChoice
        .then(function(choiceResult) {
          // The user actioned the prompt (good or bad).
          // good is handled in 
          promptEvent = null;
          ga('send', 'event', 'install', choiceResult);
          root.classList.remove('available');
        })
        .catch(function(installError) {
          // Boo. update the UI.
          promptEvent = null;
          ga('send', 'event', 'install', 'errored');
          root.classList.remove('available');
        });
    }
  };

  const installed = function(e) {
    promptEvent = null;
    // This fires after onbeforinstallprompt OR after manual add to homescreen.
    ga('send', 'event', 'install', 'installed');
    root.classList.remove('available');
  };

  const beforeinstallprompt = function(e) {
    promptEvent = e;
    promptEvent.preventDefault();
    ga('send', 'event', 'install', 'available');
    root.classList.add('available');
    return false;
  };

  window.addEventListener('beforeinstallprompt', beforeinstallprompt);
  window.addEventListener('appinstalled', installed);

  root.addEventListener('click', install.bind(this));
  root.addEventListener('touchend', install.bind(this));
};

const AirHorn = function(root) {
  // Controls the AirHorn.

  const airhornImage = root.querySelector('.horn');
  const horn = new Horn();

  const start = function(e) {
    if (!!e == true) {
      if(supportsPassive == false) e.preventDefault();

      if (e.touches && e.touches.length > 1) {
        // Multi touch. OFF.
        return false;
      }
    }

    this.start({loop: true});
  };

  const stop = function(e) {
    if (!!e == true) e.preventDefault();
    this.stop();
  };

  this.start = function(opts) {
    // Play the sound
    airhornImage.classList.add('horning');
    horn.start(opts);

    horn.onstopped = function() {
      airhornImage.classList.remove('horning');
    };

    ga('send', 'event', 'horn', 'play');
  };

  this.stop = function() {
    // Stop the sound
    airhornImage.classList.remove('horning');
    horn.stop();
  };

  // Test to see if passive events listener are supported.
  let supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, 'passive', {
      get: function() {
        supportsPassive = true;
      }
    });
    window.addEventListener('testPassive', null, opts);
    window.removeEventListener('testPassive', null, opts);
  } catch (e) {}

  airhornImage.addEventListener('mousedown', start.bind(this),
      supportsPassive ? { passive: true } : false);
  airhornImage.addEventListener('touchstart', start.bind(this),
      supportsPassive ? { passive: true } : false);

  document.documentElement.addEventListener('mouseup', stop.bind(this));
  document.documentElement.addEventListener('touchend', stop.bind(this));
};

window.addEventListener('load', function() {
  const airhornEl = document.getElementById('airhorn');
  const installEl = document.getElementById('installer');
  const airhorn = new AirHorn(airhornEl);
  const installer = new Installer(installEl);
  let isLooping = false;

  if (Comlink && window.opener) {
    // We are ready. Tell the opener.
    const channel = new MessageChannel();
    const port1 = channel.port1;
    Comlink.expose(airhorn, port1);
    opener.postMessage({'cmd': 'READY'}, '*', [channel.port2]);
  }

  if (navigator.presentation && navigator.presentation.receiver) {
    navigator.presentation.receiver.connectionList.then(list => {
      list.connections.forEach(connection => {
        Comlink.expose(airhorn, MessageChannelAdapter.wrap(connection));
      });
      list.onconnectionavailable = event => {
        Comlink.expose(airhorn, MessageChannelAdapter.wrap(event.connection));
      };
    });
  }

  if (location.hash == '#instant') {
    airhorn.start({loop: false});
  }

  window.addEventListener('hashchange', function() {
    if (location.hash == '#instant') {
      airhorn.start({loop: false});
    }
  });

  document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
      airhorn.stop();
    }
  });
});
})();
</script>
</head>
<body>
<div class="container-fluid">
  <nav class="nav-wrapper green lighten-2">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header green lighten-2">
      &nbsp; &nbsp; <!--<a class="brand-logo center" style="font-family: 'Gugi', cursive; color:white; font-size:30px;" href="#">UFFL</a>-->
      <img src="assets/UFFLLogo.png" class="brand-logo center" style="margin-top:2px;" alt="UFFL" height="50" width="150">
    </div>
</nav>
<div class="container">
<div align="center">
<%= form_for(:session, url: login_path) do |f| %>
  &nbsp; &nbsp; <div class="form-group">
  <%= f.email_field :email, :placeholder => " Email", :class => "form-control input-field" %> 
  </div>
  &nbsp; &nbsp; <div class="form-group">
  <%= f.password_field :password, :placeholder => " Password", :class => "form-control" %>
  </div>
  <div class="form-group">
  <%= f.submit "Log in", :class => "btn btn-success" %>
  </div>
  <br />
  Forgotten password? <%= link_to "Reset", new_password_reset_path %>
  <br/>
  New user? <%= link_to "Sign up now!", signup_path %>
  <% flash.each do |key, value| %>
  <%= content_tag :div, value, class: "z-depth-5 login_errors alert-#{key}" %>
<% end %>
<% end %>
<div id="installer" class="available">
  <button class="button">Install</button>
</div>
</div>
</html>
